# Rydora-Ride-Sharing-App-for-Real-World-Urban-Mobility

Rydora: Detailed Technical Specification

1. Mapping & Routing Strategy

Passenger Side: GraphHopper API

The passenger application requires high-precision pathfinding to provide accurate fare estimates and "Distance-to-Destination" metrics.

Implementation: The app sends a GET request to the GraphHopper Routing API with the start and end lat/lng coordinates.

Data Utilization: The JSON response (paths, distance, and weight) is used to draw the Polyline on the map and calculate the price based on a price_per_km constant.

Rider Side: OpenStreetMap (OSM)

For the driver, cost-efficiency and real-time updates are prioritized.

Implementation: Uses flutter_map with openstreetmap tiles.

Functionality: The driver's location is sampled every 5-10 seconds and pushed to the riders_location collection in Firestore. This data acts as the heartbeat for the matching engine.

2. The Python "Admin" Matcher (Jupyter)

Since there is no standalone admin application, the Jupyter Notebook acts as the system's brain and administrative console.

A. The Matching Loop

The notebook runs a continuous while True loop (or a listener) that performs the following:

Fetch Requests: Queries Firestore for documents in ride_requests where status == "pending".

Spatial Query: For each request, it fetches all "online" drivers from the active_riders collection.

Haversine Calculation:

# Logic used within the Notebook
def calculate_distance(p1, p2):
    # Haversine formula implementation
    return distance


Assignment: The driver with the smallest distance is selected, and the Firestore document is updated with rider_id and status: "matched".

B. Admin Tasks via Python

Manual interventions are handled through dedicated code blocks in the notebook:

User Management: Querying the users collection to ban/unban or verify drivers.

Analytics: Using pandas and matplotlib to visualize ride density or peak hours based on historical Firestore data.

System Reset: A script to clear stuck "active" rides in case of driver app crashes.

3. Data Flow Architecture

Component

Technology

Primary Responsibility

User App

Flutter / GraphHopper

Geocoding, Route Preview, Payment Trigger

Rider App

Flutter / OSM

Background Location Tracking, Route Navigation

Database

Firebase Firestore

Real-time state synchronization between all nodes

Logic Layer

Python (Jupyter)

Greedy matching, Ride lifecycle management, Admin overrides

4. Key Technical Advantages

Decoupled Logic: By putting the matching logic in Python rather than the Flutter apps, the system is more secure. Users cannot manipulate the matching algorithm.

Cost Optimization: Using OSM for the high-traffic driver tracking saves significant costs compared to proprietary map APIs.

Admin Flexibility: The Jupyter environment allows for "live coding" admin tools. If a new type of report is needed, it can be written and executed instantly without redeploying an app.

5. Security & Authentication

Firestore Security Rules: Configured to allow passengers to write requests but only allow the Python Admin (via Service Account) to modify the rider_id field.

OTP Verification: A 4-digit code is generated by the Python script upon matching, which the driver must enter into their app to begin the trip.
Rydora: Setup and Execution Manual

This guide outlines the steps to install, configure, and run the Passenger App, Rider App, and the Jupyter-based Administrative Matcher.

1. Prerequisites

Software Requirements

Flutter SDK: (Latest stable version) for mobile development.

Python 3.10+: For the administrative matching engine.

Jupyter Lab/Notebook: To run the administrative logic.

Firebase Tools: For managing the backend database.

API Keys & Accounts

Firebase Project: Create a project in the Firebase Console.

GraphHopper API Key: Sign up at graphhopper.com to get a routing key.

OpenStreetMap: No key required (Standard tile usage).

2. Environment Setup

A. Mobile Apps (Passenger & Rider)

Clone the repository:

git clone [https://github.com/your-repo/rydora.git](https://github.com/your-repo/rydora.git)


Configure Firebase:

Download google-services.json (Android) and GoogleService-Info.plist (iOS) from your Firebase project.

Place them in the respective android/app/ and ios/Runner/ directories.

Install Dependencies:

cd rydora_passenger && flutter pub get
cd ../rydora_rider && flutter pub get


Configure GraphHopper:

Locate the constants file (e.g., lib/core/constants.dart) and paste your API key:
const String graphHopperKey = 'YOUR_KEY_HERE';

B. Python Admin (Jupyter)

Install Python Libraries:

pip install firebase-admin pandas matplotlib ipywidgets


Service Account:

In Firebase Console: Project Settings > Service Accounts > Generate New Private Key.

Save the .json file as serviceAccountKey.json in your project folder.

3. Running the System (Execution Order)

To ensure the system syncs correctly, follow this specific startup sequence:

Step 1: Start the Database & Admin Logic

Open your terminal and launch Jupyter:

jupyter lab


Open admin_matcher.ipynb.

Run the "Initialization" cell to connect to Firestore via the Service Account.

Run the "Matching Loop" cell. This will keep the admin in a "listening" state, waiting for new ride requests.

Step 2: Launch the Rider App

Connect a physical device or emulator.

Run the Rider App:

cd rydora_rider && flutter run


Log in as a driver and toggle the "Go Online" switch. This populates the active_riders collection in Firestore.

Step 3: Launch the Passenger App

Run the Passenger App:

cd rydora_passenger && flutter run


Set a destination. The app will fetch the route from GraphHopper.

Click "Request Ride".

4. Monitoring the Workflow

Action

Monitoring Point

Request Sent

Check ride_requests collection in Firebase Console.

Matching

Watch the Jupyter Notebook console for logs (e.g., "Matched Passenger X with Rider Y").

Active Trip

Observe the Rider App receiving a push notification or UI update.

Completion

The Jupyter script will log the final distance and move the document to historical_rides.

5. Troubleshooting

No Drivers Found: Ensure the Rider App is actually in the active_riders collection and that their is_online status is true.

Map Not Loading: Check internet connectivity or verify that the flutter_map package has the correct urlTemplate for OSM.

Permission Denied: Ensure the Python script is using a Service Account with "Editor" or "Owner" permissions in Firebase.
